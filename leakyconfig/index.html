<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Leaky Config – Admin Login</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 480px;
      margin: 60px auto;
    }
    input {
      width: 100%;
      padding: 8px;
      margin: 6px 0;
      box-sizing: border-box;
    }
    button {
      padding: 8px 16px;
      margin-top: 10px;
      cursor: pointer;
    }
    #msg {
      margin-top: 16px;
      font-size: 0.95em;
    }
    .hint {
      margin-top: 32px;
      font-size: 0.85em;
      color: #777;
    }
    pre {
      background: #f5f5f5;
      padding: 8px;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <h1>Admin Panel</h1>
  <p>Please log in to access the admin area.</p>

  <div>
    <label>Username</label><br />
    <input id="username" type="text" placeholder="admin" />
  </div>
  <div>
    <label>Password</label><br />
    <input id="password" type="password" placeholder="••••••••" />
  </div>
  <button onclick="login()">Log In</button>

  <div id="msg"></div>

  <div class="hint">
    <p>This is a static version of the challenge running on GitHub Pages.</p>
    <p>Hint: In a real deployment, configuration backups must never be publicly accessible.</p>
    <p>Try exploring paths under <code>/backup/</code> and see what you can find.</p>
  </div>

  <script>
    // Encrypted flag bytes (XOR of flag chars with password chars)
    // The plaintext flag never appears in this file.
    const cipher = [
      48, 9, 19, 30, 36, 33, 1, 27, 23, 7, 6, 49, 38, 25
    ];

    let configUser = null;
    let configPass = null;

    async function loadConfig() {
      try {
        const resp = await fetch("./backup/config-prod.yaml.bak");
        if (!resp.ok) {
          console.warn("Cannot load backup config:", resp.status);
          return;
        }
        const text = await resp.text();
        // Very simple parsing by regex – enough for CTF.
        const uMatch = text.match(/username:\s*([^\s]+)/);
        const pMatch = text.match(/password:\s*([^\s]+)/);

        configUser = uMatch ? uMatch[1] : null;
        configPass = pMatch ? pMatch[1] : null;

        console.log("Config loaded from backup.");
      } catch (e) {
        console.error("Failed to load backup config:", e);
      }
    }

    function deriveFlagFromPassword(password) {
      if (!password) return null;
      const chars = [];
      const plen = password.length;
      for (let i = 0; i < cipher.length; i++) {
        const key = password.charCodeAt(i % plen);
        const ch = String.fromCharCode(cipher[i] ^ key);
        chars.push(ch);
      }
      return chars.join("");
    }

    async function login() {
      const username = document.getElementById("username").value.trim();
      const password = document.getElementById("password").value.trim();
      const msg = document.getElementById("msg");

      if (!configUser || !configPass) {
        msg.textContent =
          "The server configuration is not loaded yet. Please try again in a moment.";
        return;
      }

      if (username === configUser && password === configPass) {
        const flag = deriveFlagFromPassword(password) || "flag not available";
        msg.innerHTML =
          "Welcome, admin.<br><br>Here is your flag:<br><pre>" +
          flag +
          "</pre>";
      } else {
        msg.textContent = "Invalid username or password.";
      }
    }

    // Load the leaked backup config as soon as the page opens
    loadConfig();
  </script>
</body>
</html>
